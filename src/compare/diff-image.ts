/**
 * Diff image generation with various styles
 */

import sharp from 'sharp'
import type { DiffStyle } from '../types.js'
import { logger } from '../utils/logger.js'

/**
 * Generate heatmap from diff buffer
 * Already generated by pixelmatch, just return as-is
 */
function generateHeatmap(diffBuffer: Buffer): Buffer {
  return diffBuffer
}

/**
 * Generate side-by-side comparison image
 * Layout: baseline (left) | diff (center) | current (right)
 */
async function generateSideBySide(baselinePath: string, currentPath: string, diffBuffer: Buffer): Promise<Buffer> {
  const baseline = sharp(baselinePath)
  const current = sharp(currentPath)
  const diff = sharp(diffBuffer)

  const baselineMeta = await baseline.metadata()
  const width = baselineMeta.width || 0
  const height = baselineMeta.height || 0

  // Resize images to same height if needed
  const resizedBaseline = await baseline.resize({ width, height, fit: 'contain' }).toBuffer()
  const resizedCurrent = await current.resize({ width, height, fit: 'contain' }).toBuffer()
  const resizedDiff = await diff.resize({ width, height, fit: 'contain' }).toBuffer()

  // Create composite with 3 images side by side: baseline | diff | current
  const compositeWidth = width * 3
  const compositeHeight = height

  const composite = sharp({
    create: {
      width: compositeWidth,
      height: compositeHeight,
      channels: 4,
      background: { r: 255, g: 255, b: 255, alpha: 1 },
    },
  })
    .composite([
      { input: resizedBaseline, top: 0, left: 0 },
      { input: resizedDiff, top: 0, left: width },
      { input: resizedCurrent, top: 0, left: width * 2 },
    ])
    .png()

  return await composite.toBuffer()
}

/**
 * Generate overlay comparison (baseline with diff highlighted)
 */
async function generateOverlay(baselinePath: string, diffBuffer: Buffer): Promise<Buffer> {
  const baseline = sharp(baselinePath)
  const diff = sharp(diffBuffer)

  const baselineMeta = await baseline.metadata()
  const width = baselineMeta.width || 0
  const height = baselineMeta.height || 0

  // Make diff semi-transparent
  const transparentDiff = await diff
    .ensureAlpha()
    .raw()
    .toBuffer()
    .then((buffer) => {
      // Set alpha to 0.5 for red pixels (differences)
      const data = new Uint8Array(buffer)
      for (let i = 0; i < data.length; i += 4) {
        const r = data[i]
        const g = data[i + 1]
        const b = data[i + 2]

        // If this is a red pixel (difference), make it semi-transparent
        if (r > 200 && g < 100 && b < 100) {
          data[i + 3] = 128 // 50% opacity
        } else {
          data[i + 3] = 0 // Fully transparent for non-diff pixels
        }
      }

      return sharp(Buffer.from(data), {
        raw: { width, height, channels: 4 },
      })
        .png()
        .toBuffer()
    })

  // Overlay diff on baseline
  const overlay = await baseline
    .composite([{ input: transparentDiff, blend: 'over' }])
    .png()
    .toBuffer()

  return overlay
}

/**
 * Generate blend comparison (50/50 blend of baseline and current)
 */
async function generateBlend(baselinePath: string, currentPath: string): Promise<Buffer> {
  const baseline = sharp(baselinePath)
  const current = sharp(currentPath)

  const baselineMeta = await baseline.metadata()
  const width = baselineMeta.width || 0
  const height = baselineMeta.height || 0

  // Get raw buffers
  const baselineBuffer = await baseline.ensureAlpha().raw().toBuffer()
  const currentBuffer = await current.resize(width, height).ensureAlpha().raw().toBuffer()

  // Blend 50/50
  const blended = new Uint8Array(baselineBuffer.length)
  for (let i = 0; i < baselineBuffer.length; i += 4) {
    blended[i] = Math.round((baselineBuffer[i] + currentBuffer[i]) / 2) // R
    blended[i + 1] = Math.round((baselineBuffer[i + 1] + currentBuffer[i + 1]) / 2) // G
    blended[i + 2] = Math.round((baselineBuffer[i + 2] + currentBuffer[i + 2]) / 2) // B
    blended[i + 3] = 255 // A
  }

  return await sharp(Buffer.from(blended), {
    raw: { width, height, channels: 4 },
  })
    .png()
    .toBuffer()
}

export interface DiffImageOptions {
  style: DiffStyle
  baselinePath: string
  currentPath: string
  diffBuffer: Buffer
}

/**
 * Generate diff image with specified style
 */
export async function generateDiffImage(options: DiffImageOptions): Promise<Buffer> {
  const { style, baselinePath, currentPath, diffBuffer } = options

  logger.debug(`Generating diff image with style: ${style}`)

  switch (style) {
    case 'heatmap':
      return generateHeatmap(diffBuffer)

    case 'sidebyside':
      return await generateSideBySide(baselinePath, currentPath, diffBuffer)

    case 'overlay':
      return await generateOverlay(baselinePath, diffBuffer)

    case 'blend':
      return await generateBlend(baselinePath, currentPath)

    default:
      throw new Error(`Unknown diff style: ${style}`)
  }
}
